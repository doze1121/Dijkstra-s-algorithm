# На рисунке изображена часть схемы метрополитена г. Санкт-Петербурга.
# Давайте попробуем представить ее в виде списка смежности.

G = { "Адмиралтейская": ["Садовая"],
      "Садовая": ["Адмиралтейская", "Спасская", "Сенная площадь", "Звенигородская"],
      "Спасская": ["Садовая","Сенная площадь", "Достоевская"],
      "Сенная площадь": ["Садовая", "Спасская"],
      "Достоевская": ["Спасская", "Владимирская"],
      "Владимирская": ["Достоевская", "Пушкинская"],
      "Пушкинская": ["Владимирская", "Звенигородская"],
      "Звенигородская" : ["Пушкинская", "Садовая"]
      }

#Возьмите граф из предыдущего задания (с картой метро) и постройте из него взвешенный граф.
# В качестве весов используйте время, необходимое для того, чтобы доехать (или перейти) с одной станции на другую.
# Для этого можно воспользоваться сервисом Яндекс.Метро.

G = { "Адмиралтейская": {"Садовая": 4},
      "Садовая": {"Адмиралтейская": 4,
                  "Спасская": 3,
                  "Сенная площадь": 4,
                  "Звенигородская": 5},
      "Спасская": {"Садовая": 3,
                   "Сенная площадь": 4,
                   "Достоевская": 6},
      "Сенная площадь": {"Садовая": 4,
                         "Спасская": 4},
      "Достоевская": {"Спасская": 6,
                      "Владимирская": 3},
      "Владимирская": {"Достоевская": 3,
                       "Пушкинская": 4},
      "Пушкинская": {"Владимирская": 4,
                     "Звенигородская": 3},
      "Звенигородская" : {"Пушкинская": 3,
                          "Садовая": 5}
      }


# «алгоритм Дейкстры».

D = {k : 100 for k in G.keys()}  # расстояния
start_k = input("Введите станцию отправления:")  # стартовая вершина
D[start_k] = 0  # расстояние от неё до самой себя равно нулю
U = {k : False for k in G.keys()}  # флаги просмотра вершин
P = {k : None for k in G.keys()}  # предки

for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
         if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
            D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
            P[v] = min_k  # и записываем как предок
    U[min_k] = True  # просмотренную вершину помечаем

pointer = input("Введите станцию прибывания:")  # куда должны прийти
while pointer is not None:  # перемещаемся, пока не придём в стартовую точку
    print(pointer)
    pointer = P[pointer]

# В нём отражено кратчайшее расстояние от «Адмиралтейской» до станции, которая задаёт ключ.
# Таким образом мы реализовали тот же самый алгоритм,
# который использует Яндекс для поиска кратчайшего пути между станциями!

# Алгоритм Дейкстры можно модифицировать таким образом,
# что можно определить не только величину пути, но ещё и сами вершины минимального пути.

# Для этого определим ещё один словарь P, в котором будем для каждой вершины хранить
# вершину-предок с минимальным расстоянием. P = {k : None for k in G.keys()}

